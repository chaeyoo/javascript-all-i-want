실행컨텍스트란 자바스크립트 엔진이 코드를 실행하는데 사용하는 내부 매커니즘. 이 컨텍스트는 실행되는 코드에 대한 환경 정보를 포함
변수, 함수선언, this의 값 등의 스코프 값 정보가 포함됨

즉, 실행컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 일종의 추상적인 개념임
실행 컨텍스트가 활성화 되는 시점에 호이스팅, 외부환경, this값 등을 설정한다. 

- 실행 컨텍스트의 구성
- 실행 컨텍스트로 인해 this scope, closure가 작동하는지 알아보기

함수 스코프와 클로저는 실행 컨텍스트와 밀접한 연관이 있음
function scope => 함수가 선언된 위치에 따라 결정 (lexical scoping)

실행 컨텍스트가 생성될 때, 각 함수는 자신의 Lexical Environment(함수 내부에서 선언된 변수, 함수선언, 매개변수가 포함)를 가진다. 여기에는 OuterLexicalEnvironment를 포함하는데, 이는 함수가 선언된 외부 환경이다. (상위 스코프 참조)

함수가 호출되면 새로운 실행 컨텍스트가 스택에 push되고 이 컨텍스트는 해당 함수의 스코프를 결정한다.

<<closure>>
내부 함수가 선언된 외부 함수의 실행 컨텍스트에 대한 참조를 유지할 때 발생한다. 외부 함수의 실행 컨텍스트가 종료되어 콜 스택에서 제거되더라도, 내부 함수는 외부 함수의 LexicalEnvironment에 대한 참조를 유지한다. 즉, 내부 함수는 외부 함수의 변수 및 함수에 계속 접근 가능하다. 클로저는 외부함수의 lexical environment가 가비지 컬렉터에 의해 수집되지 않고 유지 되도록 하며, 이는 내부함수가 외부 함수의 변수에 접근할 수 있도록 한다. 


실행 컨텍스트의 구조와 동작방식이 중요함!!
함수가 실행될 때 필요한 모든 정보를 포함하고 있다.

코드가 실행되는데 필요한 모든 정보와 자원을 담고있는 가상의 작업 공간이다. 자바스크립트 엔진에 장착이 되어있다. 프로그램 실행 흐름을 제어하는데 필수적이다. 현재 실행되는 코드에 대한 환경과 상태 정보를 담고 있으며, 이것은 변수, 객체, 함수 호출과 같은 코드에 필요한 여러 세부 사항을 포함한다. 

<실행 컨텍스트와 책상의 비유>
- 실행 컨텍스트 
    :책상
- 변수 및 함수 
    : 책상 위 물건
- this 키워드 (실행 컨텍스트의 주인)
    : 책상 주인
- scope 생명 주기 (변수가 버려지거나 재사용 됨) 
    : 책상의 정리
- 함수 호출과 실행 컨텍스트 스택 
    : 새로운 책상이 준비가 됨
    : 여러 함수 호출 시엔 중첩 가능

<this>
 - this는 실행 컨텍스트에서 수행되는 작업을 지시한다. 실행 컨텍스트가 생성될 때 this 가 바인딩 된다. (자동으로 정해짐)

 전역 공간에서 this는 전역 객체를 가리킴
 브라우저에서는 윈도우, node.js에서는 글로벌
 객체의 메서드를 함수로 호출할 때 this는 메서드를 호출한 객체가 되고 생성자 함수로 (new로 객체를 만들 때는) 새로 만들어진 객체를 가리킨다. call, apply, bind 같은 메서드를 사용해서 원하는 대로 지정할 수도 있다.


 스코프란 어떤 변수와 함수에 접근할 수 있는지 결정하는 규칙
 실행 컨텍스트로 스코프를 설명하기

 Q. 전역 변수는 왜 메모리 누수를 일으킬까요??
 - 글로벌 실행 컨텍스트는 프로그램이 종료될 때까지 호출스택에 남아있는다. 따라서 전역 변수들도 프로그램이 실행되는 동안 메모리에 계속 유지가 된다. 이런 특성 때문에 전역 변수를 과도하게 사용하는 것은 메모리 사용량을 증가시키고 성능 문제나 메모리 누수가 될 수 있음. 큰 객체나 배열의 경우 메모리 사용량이 더욱 증가한다. 전역 변수는 자동적으로 가비지 컬렉터의 대상에서 제외가 된다.  따라서 더이상 필요하지 않은 데이터를 전역변수로 유지하면 메모리 누수가 발생할 위험이 크다.

가능한 함수 내부에서 지역 변수를 사용하고 전역 변수 사용은 최소화해야 한다. 또는 모듈 패턴이나 자바스크립트의 최신 모듈 시스템을 사용하여 전역 네임스페이스의 오염을 방지한다. 또한, 
관련된 여러 전역 변수를 객체 속성으로 그룹화하여 관리할 수도 있다.

코드를 구조화하고, 스코프 관리를 적절히 하여 안정적이고 효율적인 애플리케이션 개발!