열린 변수식을 닫힌 변수 식으로 변환
외부 스코프의 변수에 접근해서 그 변수가 가비지 컬렉션의 대상에서 제외 되도록 함
함수의 실행 컨텍스트가 종료되어도 해당 변수를 계속 참조할 수 있게 해줌
클로저는 내부 함수가 외부 함수의 변수에 접근할 때 형성됨
내부함수는 외부함수가 실행될 때 생성된 실행 컨텍스트의 변수를 기억하여
데이터를 은닉하고 캡슐화하는데 활용이 된다.
클로저의 대표 예시는 
1) 커링함수가 있음 커링은 함수의 부분적용과 지연 실행을 가능하게 해주는 기법
함수의 인자를 나눠 받으며 각 단계에서 클로저 생성하여 이전 단계의 인자를 기억
2) 리액트의 useState, useEffect

주요 클로저 사용 이유
함수형 프로그래밍에서 중요한 역할
- 특히 변수의 유효 범위와 데이터 캡술화등 이점 제공

클로저를 통해 외부함수의 변수 기억, 활용 
리액트에서 클로저의 역할
상태관리와 라이프 사이클 관리 등 중요한 역할을 함

* 클로저 사용하는 주요 이유
1) 캡슐화
- 데이터와 데이터를 조작하는 함수를 하나의 단위 (클래스나 모듈) 같은 구조 안에 묶는 기법
 - 클로저는 자바스크립트에서 캡슐화를 구현
 - 특정 함수를 통해서만 데이터에 접근하도록 제한
 ex) counter 함수는 내부 count 변수를 가지고 이변수는 외부에서 직접 접근 불가
 count 값을 변경, 조회하기 위해서는 특정 함수에 접근 해야 함

2) 데이터 은닉
구현 세부 사항을 숨기고 사용자에게 필요한 기능만 제공
프로그램의 안전성을 높이고 사용자의 실수로 부터 중요 데이터 보호
클로저는 외부 스코프로 부터 독립된 변수를 가질 수 있어서 외부로 부터 변수 보호
데이터 직접 변경 방지, 무분별한 변경 방지

3) 상태 유지
- 어떤 데이터의 현재 상태 값을 시간이 지나도 유지
- 함수가 생성될 때 환경을 기억하고 이를 통해 해당 환경의 변수들의 상태를 유지
- 클로저는 이런 변수들을 자신의 스코프 내에 안전하게 보관하며 외부의 영향으로 부터 독립적
- counter함수는 여러번 호출되어도 이전의 count 상태를 유지하여, 그것을 기반으로 연산
- 커링함수, 지연함수 실행 가능

[참고] 커링함수
커링: 여러 인자를 받는 함수를 단일 인자를 받는 함수로 변환하여
각각의 인자를 순차적으로 받는 연속된 함수의 체인으로 만듦

커링된 함수는 하나의 인자를 받고 그 인자를 기억하며 다음 인자를 받기 위한 새로운 함수를 반환하고 그 과정은 모든 인자가 제공될 때까지 계속 됨

함수의 재사용성과 모듈성을 높임
함수의 지연 실행 및 부분 적용을 가능하게 함
=> 반복되는 인자를 가진 함수 호출에서 유용



미들웨어에서는 지연 실행이 중요함 커링함수는 지연 실행을 효율적으로 활용할 수 있음

리덕스의 미들웨어 구조 : 커링과 지연 실행 활용
const middleware = store => next => action => {
    // 미들웨어 로직
}

1단계 함수 : store (리덕스 스토어를 매개변수로 받음) 미들웨어가 현재 상태를 조회하거나 새로운 액션 디스패치
2단계 함수 : next 를 매개변수로 받음. next는 action을 다음 미들웨어로 전달하거나 middleware 체인의 마지막에 도달했다면
리듀서로 전달
3단계 함수: 실제 dispatch 된 action을 매개변수로 받음. 미들웨어는 필요한 로직을 수행하고 액션을 수정하거나 추가적인 액션을 dispatch 혹은 무시

리덕스 미들웨어에서 커링과 지연실행을 기반으로 강력한 패턴 제공
여러 단계의 함수를 통해 각각의 인자를 차례대로 받음 
각 단계 함수는 다음 단계 함수 반환
각 단계 함수는 실제 해당 단계 인자가 제공될 때까지 실행 지연

리액트에서 클로저는 hook과 관련하여 자주 언급이 됨

* useState hook
: 클로저를 통해 컴포넌트 상태 관리
함수 컴포넌트는 상태가 변경될 때마다 새로운 인스턴스를 생성하기 떄문에 초기화된 상태만 가질 수 있었는데,

hook을 사용하면 함수 컴포넌트 내에서 상태를 선언하고 관리 가능
함수 컴포넌트가 다시 실행되어도, 해당 함수의 상태값이 초기화되지 않고 React에 의해 사라지지 않음


useEffect의 콜백함수는 클로저로 구현이 되어있다.
의존성 배열을 통해 클로저의 특성을 적절히 관리
useEffect의 의존성 배열은
클로저 트랩을 피하기 위해서 명시 

클로저는 자신이 생성될 때 환경을 기억하는 함수
useEffect 콜백이 컴포넌트의 렌더링 시점에서 상태와 프롭스를 캡처할 수 있도록 함
클로저는 생성될 때 상태를 기억함 
따라서 의존성 배열에 상태를 명시하지 않는다면 상태가 변경되어도 useEffect의 callback함수는 
변화를 인지하지 못하고 초기값만을 참조함

의존성 배열에 특정 상태를 추가하면, 해당 상태가 변경될 때마다 useEffect callback 함수가 다시 생성되고
이를 통해 콜백함수는 항상 최신 상태값을 기억하게 됨